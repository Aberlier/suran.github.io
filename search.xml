<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学长给你们的大学指南</title>
    <url>/2019/10/27/%E9%80%81%E7%BB%99%E5%A4%A7%E4%B8%80%E7%9A%84%E4%BD%A0%E4%BB%AC/</url>
    <content><![CDATA[<h3 id="啰嗦前言"><a href="#啰嗦前言" class="headerlink" title="啰嗦前言"></a>啰嗦前言</h3><p>很荣幸受邀来参加咱系的新老生交流会，其实我挺愿意参加这种会的，并不是为了展示啥我有多厉害，多牛，而是在这个会中能够让学弟学妹们感受一下咱系的优秀种子选手们都是啥样的，感受一下学长学姐们的大学，树立一个正确的前进方向，看看学姐们都是怎么过来的，对比一下自己。学弟们不要被网游啥的所耽误，学妹们应该还好些，但是从我们专业的女生来看，大多数都知道努力，但是什么都很认真，学妹们，说真的，该认真认真，不该认真就差不多就行，把更多精力放在你想走的那条路上，或者你觉得你有比这更重要，更有意义的事。比如上心理健康教育课，思修课，你觉得除了听应该还可以干点别的，把英语、高数作业写了，学弟们研究一下C语言编程题，到时候你就会发现，这些课能干很多东西，哈哈哈，其实我就是一直这么干的，我觉得这样挺好的，起码别人写作业，我就完成了。这就是一个可以利用时间的小方法，我希望通过这次的交流会让大家能够树立起一个正确的前进方向，能够拥有一个充实的大学生活，我想哪怕有一个人听我叨叨半天，能够真正的收到了启发，找到了自己前行的路，那都是影响一生的事情，何乐而不为呢？我短短十五分钟的讲解，在台上我可能讲的不太全面，在这上面我就详细的给大家做一个总结，希望你们能够看完！哈哈哈哈~</p>
<h3 id="我的入学规划"><a href="#我的入学规划" class="headerlink" title="我的入学规划"></a>我的入学规划</h3><p>在高考之后我就对自己的大学生活做了详细的规划，现在你们做也不晚，有句话，<strong>心之所向，素履以往，生如逆旅，一苇以航</strong>，想问啥意思自己去查哈,所以你现在还没有规划，那就先去规划一下，不要太大，只要你能办到就行，从前有一个朋友，和我说你的目标是什么？我说目标？我没有目标，因为我目标太多了，都是小目标，比如今晚要把作业写完，周三要在演讲比赛上更加出彩，下周的计算机技能大赛我要好好准备，一个月后我要干兼职赚1000，两个月后要怎样怎样，半年后怎样怎样，我的目标也在随着我的成长在变化，不断地革新，但是从没有偏移，一直是秉承着锻炼自己，提升自己为主要目标，大学短短四年，大学能体验很多你体验不到的东西，这其中的机会是你人生中能体验机会最多的，多去参加活动，比赛，竞技，别怕浪费时间，有些东西都是在不段的</p>
]]></content>
      <categories>
        <category>生活与你</category>
      </categories>
      <tags>
        <tag>送给大一的你们</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网大厂常考笔试题004-继承于组合的区别</title>
    <url>/2019/10/23/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98004-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="互联网大厂常考笔试题004-继承于组合的区别"><a href="#互联网大厂常考笔试题004-继承于组合的区别" class="headerlink" title="互联网大厂常考笔试题004-继承于组合的区别"></a>互联网大厂常考笔试题004-继承于组合的区别</h2><p> 本文链接：<a href="https://blog.csdn.net/zymx14/article/details/79605926" target="_blank" rel="noopener">https://blog.csdn.net/zymx14/article/details/79605926</a> </p>
<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>继承是面向对象三大基本特征之一(继承，封装，多态)，继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。在java中通过关键字extends实现继承，java中所有类默认都是java.lang.Object的子类。继承强调的是is-a关系。<br>直接通过例子来了解继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是动物 相当于父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breahing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"呼吸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyingAnimals</span> <span class="title">extend</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flying</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"飞-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FlyingAnimals flyingAnimals=<span class="keyword">new</span> FlyAnimals();</span><br><span class="line">        flyingAnimals.breathing();</span><br><span class="line">        flyingAnimals.flying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">呼吸</span><br><span class="line">飞-----</span><br></pre></td></tr></table></figure>

<p> 继承是代码复用的一种方式。在继承中，父类的方法内部实现细节对子类可见，是‘白盒式’的代码复用。 </p>
<h3 id="什么是组合"><a href="#什么是组合" class="headerlink" title="什么是组合"></a>什么是组合</h3><p>组合是通过 对现有对象进行拼装即组合产生新的具有更复杂的功能。如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breahing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"呼吸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 爬行动物</span></span><br><span class="line"><span class="comment"> * 组合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reptilia</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reptilia</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crawling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爬行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        animal.breathing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Reptilia reptilia = <span class="keyword">new</span> Reptilia(animal);</span><br><span class="line">        reptilia.breathing();;</span><br><span class="line">        reptilia.crawling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>呼吸</p>
<p>爬行…</p>
<p> 组合体现的是整体和部分，强调的是has-a的关系。所以组合更多的用于下面这样的场景： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//轮胎</span><br><span class="line">class Tire&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">	System.out.println(&quot;轮胎转动...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//灯</span><br><span class="line">class Light&#123;</span><br><span class="line">public void light()&#123;</span><br><span class="line">	System.out.println(&quot;灯亮...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Tire tire;</span><br><span class="line"> <span class="keyword">private</span> Light light;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Vehicle</span><span class="params">(Tire tire,Light light)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.tire=tire;</span><br><span class="line"> <span class="keyword">this</span>.light=light;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line"> light.light();</span><br><span class="line"> tire.run();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> Tire tire =<span class="keyword">new</span> Tire();</span><br><span class="line"> Light light=<span class="keyword">new</span> Light();</span><br><span class="line"> Vehicle vehicle=<span class="keyword">new</span> Vehicle(tire,light);</span><br><span class="line"> vehicle.operation();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>灯亮…</p>
<p>轮胎转动…</p>
<h3 id="继承与组合的区别与联系"><a href="#继承与组合的区别与联系" class="headerlink" title="继承与组合的区别与联系"></a>继承与组合的区别与联系</h3><p>继承与组合都是面向对象中代码复用的方式。父类的内部细节对子类可见，其代码属于白盒式的复用，而组合中，对象之间的内部细节不可见，其代码属于黑盒式复用。继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。继承强调的是is-a的关系，而组合强调的是has-a的关系。</p>
<h3 id="继承与组合的优缺点"><a href="#继承与组合的优缺点" class="headerlink" title="继承与组合的优缺点"></a>继承与组合的优缺点</h3><h5 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h5><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>支持扩展，通过继承父类实现，但会使系统结构较复杂<br>易于修改被复用的代码</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>代码白盒复用，父类的实现细节暴露给子类，破坏了封装性<br>当父类的实现代码修改时，可能使得子类也不得不修改，增加维护难度。<br>子类缺乏独立性，依赖于父类，耦合度较高<br>不支持动态拓展，在编译期就决定了父类</p>
<h5 id="组合的优缺点"><a href="#组合的优缺点" class="headerlink" title="组合的优缺点"></a>组合的优缺点</h5><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><p>代码黑盒复用，被包括的对象内部实现细节对外不可见，封装性好。<br>整体类与局部类之间松耦合，相互独立。<br>支持扩展<br>每个类只专注于一项任务<br>支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)</p>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>创建整体类对象时，需要创建所有局部类对象。导致系统对象很多。<br>什么情况下使用继承，什么情况下使用组合<br>从前面的分析看，组合的优点明显多于继承，再加上java中仅支持单继承，所以：<br>除非两个类之间是is-a的关系，否则尽量使用组合。<br>// <a href="https://blog.csdn.net/zymx14/article/details/79605926" target="_blank" rel="noopener">https://blog.csdn.net/zymx14/article/details/79605926</a></p>
]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>面试笔试</tag>
        <tag>java</tag>
        <tag>继承与组合的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>关于学生总成绩排名问题及Collections使用</title>
    <url>/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="关于学生总成绩排名问题及Collections使用"><a href="#关于学生总成绩排名问题及Collections使用" class="headerlink" title="关于学生总成绩排名问题及Collections使用"></a>关于学生总成绩排名问题及Collections使用</h2><p>写一个项目真是存在很多的bug,修复的时间往往比开发所需要的时间更长，今天又出了一个bug,在这里记录一下，主要是针对系统中学生的成绩排名。</p>
<h4 id="出现的问题是当管理员对成绩进行删除操作的时候排名不会变化"><a href="#出现的问题是当管理员对成绩进行删除操作的时候排名不会变化" class="headerlink" title="出现的问题是当管理员对成绩进行删除操作的时候排名不会变化"></a>出现的问题是当管理员对成绩进行删除操作的时候排名不会变化</h4><p>因为成绩是以Excel表格的形式进行导入的，在导入的同时对里面的成绩进行汇总和排序，在排序上分别对学生成绩的班级进行排名和全校名次进行排名，排名的关键点就是考试的批次，这么说可能有点笼统，下面举个栗子：</p>
<p> <img alt="img" data-src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1571755425&di=89f9186748746fae06a09b354579d8ed&src=http://himg2.huanqiu.com/attachment2010/2017/0411/20170411011851880.jpg" class="lozad"> </p>
<h6 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h6><p>成绩由管理员和教师进行上传，上传的同时教师选择考试批次：第一次模拟考试 ，选择班主任，选择Excel文件，然后点击导入。对于导入文件功能等过几天我在发布上来。</p>
 <img class="lozad" title="This is an example image" data-src="/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/1571755614542.png"> 

<p>在后台就是</p>
 <img class="lozad" title="This is an example image" data-src="/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/1571756051728.png"> 

<p>在这里可以看到考试批次的eid编号，所以在排序的时候sql语句加一个where值为eid，根据考试批次进行班级和全校的排名。</p>
<h4 id="以区域排名为例"><a href="#以区域排名为例" class="headerlink" title="以区域排名为例"></a>以区域排名为例</h4><pre><code>Control
//区域排名
    List&lt;Score&gt; listAllR = scoreService.findRegionalranking(eid);//获取学生的班级排名
    if(listAllR==null||listAllR.equals(&quot;&quot;)){
        String failurl=request.getContextPath()+&quot;/ScoreServlet?action=adm_findAllScore&quot;;
        String msg = &quot;&lt;script&gt;window.alert(&apos;该考试批次已不存在相关学生成绩！&apos;);window.location.href=&apos;&quot;+failurl+&quot;&apos;;&lt;/script&gt;&quot;;
        request.setAttribute(&quot;msg&quot;, msg);
        request.getRequestDispatcher(&quot;msg.jsp&quot;).forward(request, response);    
    }else{
        Collections.sort(listAllR);//将数据库查询的数组进行排序
        for (int i = 0; i &lt;listAllR.size(); i++) {
            listAllR.get(i).setRegionalranking(i+1+&quot;&quot;);
            scoreService.updateRegionalranking(listAllR.get(i));
        }
    }</code></pre><h3 id="Collections-中有一个方法叫做sort可以对集合中的内容进行排序"><a href="#Collections-中有一个方法叫做sort可以对集合中的内容进行排序" class="headerlink" title="Collections 中有一个方法叫做sort可以对集合中的内容进行排序"></a>Collections 中有一个方法叫做sort可以对集合中的内容进行排序</h3><p> static void sort(List list)： 对集合中的内容进行排序</p>
<p>要使用这个sort方法进行排序的集合，里面的泛型必须实现Comparable接口</p>
<p>实现这个接口的对象才具备排序的功能， 这种排序自然排序。</p>
<p>口诀：<br>升序就是我减他，降续就是他减我</p>
<p>想要在哪个对象中使用就要继承Comparable接口</p>
 <img class="lozad" title="This is an example image" data-src="/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/1571757435627.png"> 

<p>与此同时我们按照降序排列</p>
<img class="lozad" title="This is an example image" data-src="/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/1571757402288.png"> 

<p>然后调用scoreService.updateRegionalranking(listAllR.get(i));这个方法，将请求送到Dao，最后修改排名。</p>
<h3 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h3><p>未删除成绩前界面如下：</p>
<img class="lozad" title="This is an example image" data-src="/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/1571757792968.png"> 

<p>点击删除乔峰，木婉清就变成了第一名，效果如下</p>
<img class="lozad" title="This is an example image" data-src="/2019/10/22/%E5%85%B3%E4%BA%8E%E5%AD%A6%E7%94%9F%E6%80%BB%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%98%E5%8F%8ACollections%E4%BD%BF%E7%94%A8/1571757871623.png"> 

<p>总之，还是很烦返修程序的，但是程序都是在不断的探索中逐步强化，自身的能力也是一样，写到这里了，睡觉去，猪儿说不能熬夜！❤</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排名</tag>
        <tag>Collections</tag>
        <tag>猪儿</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网大厂常考笔试题003-overload与override的区别</title>
    <url>/2019/10/22/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98003-overload%E4%B8%8Eoverride%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="互联网大厂常考笔试题003-overload与override的区别"><a href="#互联网大厂常考笔试题003-overload与override的区别" class="headerlink" title="互联网大厂常考笔试题003-overload与override的区别"></a>互联网大厂常考笔试题003-overload与override的区别</h2><p>本文链接：<a href="https://blog.csdn.net/scau_lth/article/details/83413082" target="_blank" rel="noopener">https://blog.csdn.net/scau_lth/article/details/83413082</a></p>
<h6 id="Override：重写-Overload：重载"><a href="#Override：重写-Overload：重载" class="headerlink" title="Override：重写                                Overload：重载"></a>Override：重写                                Overload：重载</h6><p>这两者之间的区别在很多Java的面试笔试中都会经常被问到，下面我就捋一下他们的区别。</p>
<p>重写(Override)也称覆盖，它是父类与子类之间多态性的一种表现，而重载(Overload)是一个类中多态性的一种表现。</p>
<p>override从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。overload它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，虚拟机就会根据不同的参数样式，来选择合适的方法执行。</p>
<h2 id="override（重写，覆盖）"><a href="#override（重写，覆盖）" class="headerlink" title="override（重写，覆盖）"></a>override（重写，覆盖）</h2><p>（1）方法名、参数、返回值相同。<br>（2）子类方法不能缩小父类方法的访问权限。<br>（3）子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。<br>（4）存在于父类和子类之间。<br>（5）方法被定义为final不能被重写。<br>（6）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<h2 id="overload（重载，过载）"><a href="#overload（重载，过载）" class="headerlink" title="overload（重载，过载）"></a>overload（重载，过载）</h2><p>（1）参数类型、个数、顺序至少有一个不相同。<br>（2）不能重载只有返回值不同的方法名。<br>（3）针对于一个类而言。<br>（4）不能通过访问权限、返回类型、抛出的异常进行重载；<br>（5）方法的异常类型和数目不会对重载造成影响。</p>
<h2 id="override应用"><a href="#override应用" class="headerlink" title="override应用"></a>override应用</h2><p>（1）最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。<br>（2）除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>override是在不同类之间的行为，overload是在同一个类中的行为。</p>
<p>overload的方法可以改变返回值的类型，因为它与返回值类型无关。</p>
]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>面试笔试</tag>
        <tag>java</tag>
        <tag>overload与override的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网大厂常考笔试题002-final的作用</title>
    <url>/2019/10/22/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98002-final%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>今天讲一下final关键字的作用，final关键字可用于三个地方，一个作用是修饰类、一个作用是修饰类属性、一个作用是修饰类方法。</p>
<p> 被final关键字修饰的类不能被继承，被final关键字修饰的类属性和类方法不能被覆盖（重写）。</p>
<p>   对于被final关键字修饰的类属性而言，子类就不能给他重新赋值了，如果重新赋值，会报错：</p>
<img class="lozad" title="This is an example image" data-src="/2019/10/22/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98002-final%E7%9A%84%E4%BD%9C%E7%94%A8/20171011122829016.png"> 

<p>下图所示，当我们直接给name赋值时，因为父类中的name属性被final修饰，所以eclipse会报错。但是这里有一个特别容易混淆的地方：</p>
<img class="lozad" title="This is an example image" data-src="/2019/10/22/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98002-final%E7%9A%84%E4%BD%9C%E7%94%A8/20171011123208548.png"> 



<p>请注意，我们在name之前加上了一个String关键字，其结果是从新发定义了一个变量，虽然变量名都是name，但是在内存中占用的区域却不同，所以不与之冲突，不会报错。</p>
<p>接下来是在类方法前加上final关键字的用法。与类属性类似，父类方法如果用final关键字进行修饰，那么不能被覆盖，但要说明一点的是，不能被重写是指不能同时和和父类方法同名，同参数，换句话讲，只要子类中的方法与父类中的方法同名，同参数列表，即使返回值不同，仍然是属于重写的范畴：</p>
<img class="lozad" title="This is an example image" data-src="/2019/10/22/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98002-final%E7%9A%84%E4%BD%9C%E7%94%A8/20171011125023189.png"> 

<p>这里的子类方法报错，是因为他与父类中的print方法同名同参数，即使他们返回值不同，但仍然是属于重写的范畴。所以这里有一个小结论：</p>
<p>重写：只要子类方法与父类方法同名同参数就是重写。</p>
]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试笔试</tag>
        <tag>笔试final的作用</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网大厂常考笔试题001-static的作用</title>
    <url>/2019/10/21/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E5%B8%B8%E8%80%83%E7%AC%94%E8%AF%95%E9%A2%98001-static%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>今天摘选了一些著名互联网企业的一些Java面试笔试真题以及考察知识点，以便提供读者参考。</p>
<h2 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h2><p>static关键字有以下三种使用方法：</p>
<p>1.被static修饰的变量属于静态变量，类变量，可以通过类名，变量名直接引用，不需要进行new一个新类。</p>
<p>2.被static修饰的方法属于静态方法，类方法，可以通过类名，方法名直接引用，而不需要new出来一个对象</p>
<p>3.静态块，用于初始化一个类的时候进行一些操作，静态变量、静态方法和静态代码块都只执行一次，而且只在初始化的时候执行。</p>
<h6 id="首先静态变量："><a href="#首先静态变量：" class="headerlink" title="首先静态变量："></a>首先静态变量：</h6><p> 静态变量被所有变量所共享，在内存中只存在一种副本，只在（当且仅当）类初次加载时被初始化，生命周期边长，只有程序结束才能够被销毁。而非静态变量是单个对象所拥有的，存在多个副本，各个对象之间副本互不影响。</p>
<h6 id="其次静态方法："><a href="#其次静态方法：" class="headerlink" title="其次静态方法："></a>其次静态方法：</h6><p>静态方法是所有类都能够调用和共同存在的方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为this表示是当前对象，因为它不依附于任何对象，既然都没有对象，就谈不上this了。 并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 最大的作用就是可以”类名.方法名”调用该方法。但是在实际开发中也少用到该方式，因为一是static修饰后的方法资源共享，在多线程场景不安全。二是静态资源常驻内存，很难被回收， </p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p> 被static修饰的变量和被static修饰的方法统一属于类的<strong>静态资源，是类实例之间共享的，换言之，一处变、处处变</strong>。 </p>
<h6 id="最后是静态块"><a href="#最后是静态块" class="headerlink" title="最后是静态块:"></a>最后是静态块:</h6><p>static修饰静态块后，将要修饰的成员同一放在一个static中。该静态化会在第一次使用类时，最先初始化static修饰的静态块。并且在程序运行过程中，只需要初始化一次，不会进行多次初始化。以下代码是静态代码块以流的模式获取test.properties文件内容。链接 <a href="https://blog.csdn.net/chengly0129/article/details/49493297" target="_blank" rel="noopener">https://blog.csdn.net/chengly0129/article/details/49493297</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">  InputStream in = Object.class.getResourceAsStream(<span class="string">"/test.properties"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    prop.load(in);</span><br><span class="line">    param1 = prop.getProperty(<span class="string">"initYears1"</span>).trim();</span><br><span class="line">    param2 = prop.getProperty(<span class="string">"initYears2"</span>).trim();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们思考，为什么 JDK把不同的静态资源放在了不同的类中而不把所有静态资源放在一个类里面，很多人可能想当然认为当然要这么做，但是是否想过为什么要这么做呢？个人认为主要有三个好处： </p>
<p>1、不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样就很清晰了</p>
<p>2、避免重名。不同的类之间有重名的静态变量名、静态方法名也是很正常的，如果所有的都放在一起不可避免的一个问题就是名字重复，这时候怎么办？分类放置就好了。</p>
<p>3、避免静态资源类无限膨胀，这很好理解。</p>
<p> OK，再微微深入一下，也是有些人容易混淆的一个问题：静态方法能不能引用非静态资源？静态方法里面能不能引用静态资源？非静态方法里面能不能引用静态资源？比如就以这段代码为例，是否有错？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">2 </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="number">4</span>     </span><br><span class="line"><span class="number">5</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">6     </span>&#123;</span><br><span class="line"><span class="number">7</span>         i = <span class="number">1</span>;</span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当然有错，在第7行的地方。不妨这么思考这个问题：</p>
<p>静态资源属于类，但是是独立于类存在的。从JVM的类加载机制的角度讲，<strong>静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的</strong>。类的初始化早于类的new，比如Class.forName(“xxx”)方法，就是初始化了一个类，但是并没有new它，只是加载这个类的静态资源罢了。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的；但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。所以上面的几个问题答案就很明确了：</p>
<p>1、静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。</p>
<p>2、静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。</p>
<p>3、非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。</p>
]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试笔试</tag>
        <tag>笔试题static的作用</tag>
      </tags>
  </entry>
  <entry>
    <title>由于一个“ 引发的事故</title>
    <url>/2019/10/20/error001/</url>
    <content><![CDATA[<p>前阵子在写程序的时候出现了这么一个错误：<br>org.apache.jasper.JasperException: /WEB-INF/pages/accessory/accessoryHome.jsp(1,61) quote symbol expected</p>
<p>错误代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;c:when <span class="built_in">test</span>=<span class="variable">$&#123;page.page==1 &#125;</span>&gt;</span><br><span class="line">          &lt;li class=<span class="string">"active"</span>&gt;&lt;a href=<span class="string">"javascript:void();"</span> title=<span class="string">"首页"</span>&gt;首页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/c:when&gt;</span><br></pre></td></tr></table></figure>
<p>quote symbol expected：quote symbol就是引号,expected就是期待连起来就是我代码少写引号了；</p>
<p>正确代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;c:when <span class="built_in">test</span>=<span class="variable">$&#123;"page.page==1" &#125;</span>&gt;</span><br><span class="line">   &lt;li class=<span class="string">"active"</span>&gt;&lt;a href=<span class="string">"javascript:void();"</span> title=<span class="string">"首页"</span>&gt;首页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/c:when&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>错误集锦</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Exception</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>张某人技术交流站</title>
    <url>/2019/10/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
